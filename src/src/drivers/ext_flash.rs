use stm32f1xx_hal::{
    prelude::*,
    //pac::Peripherals,
    //rcc::{Clocks, APB1},
    pac::SPI2,
    gpio::*,
    gpio::gpiob::*,
    spi::*,
};

use spi_memory::{
    prelude::*,
    series25::Flash,
};

use cortex_m_semihosting::hprintln;

pub struct ExtFlash(
    // Generated by the compiler when providing it an incorrect type.
    // It's pretty ugly.
    pub Flash<Spi<
        SPI2,
        Spi2NoRemap,
        (
            PB13<Alternate<PushPull>>,
            PB14<Input<Floating>>,
            PB15<Alternate<PushPull>>
        )>,
        PB12<Output<PushPull>,
    >>
);

const FLASH_SIZE: u32 = 16*1024*1024; // 16MB

impl ExtFlash {
    pub fn dump(&mut self) {
        use crate::drivers::hio::{open, nr::open};

        const BUFFER_SIZE: usize = 32*1024; // 32KB
        let mut buf = [0; BUFFER_SIZE];

        let mut file = open("ext.bin\0", open::RW_TRUNC_BINARY).unwrap();

        for addr in (0..FLASH_SIZE).step_by(BUFFER_SIZE) {
            self.0.read(addr, &mut buf).unwrap();
            file.write_all(&buf).unwrap();
        }

        hprintln!("DONE").unwrap();
    }
}
