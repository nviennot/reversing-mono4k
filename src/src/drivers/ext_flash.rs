use stm32f1xx_hal::{
    prelude::*,
    //pac::Peripherals,
    //rcc::{Clocks, APB1},
    pac::SPI2,
    gpio::*,
    gpio::gpiob::*,
    spi::*,
};

use spi_memory::{
    prelude::*,
    series25::Flash,
};


pub struct ExtFlash(
    // Generated by the compiler when providing it an incorrect type.
    // It's pretty dense, but not really necessary.
    pub Flash<
        Spi<
            SPI2,
            Spi2NoRemap,
            (
                PB13<Alternate<PushPull>>,
                PB14<Input<Floating>>,
                PB15<Alternate<PushPull>>
            ),
            u8,
        >,
        PB12<Output<PushPull>,
    >>
);

const FLASH_SIZE: u32 = 16*1024*1024; // 16MB

// We are reading from the SPI flash at 1.16 MB/s
// We should be getting 3x the speed

impl ExtFlash {
    pub fn dump(&mut self) {
        use crate::drivers::hio::{open, nr::open};

        const BUFFER_SIZE: usize = 32*1024; // 32KB
        let mut buf = [0; BUFFER_SIZE];

        let mut file = open("ext.bin\0", open::RW_TRUNC_BINARY).unwrap();

        for addr in (0..FLASH_SIZE).step_by(BUFFER_SIZE) {
            self.0.read(addr, &mut buf).unwrap();
            file.write_all(&buf).unwrap();
        }

        cortex_m_semihosting::hprintln!("DONE").unwrap();
    }
}
